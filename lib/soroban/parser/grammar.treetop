# Ideally we would like to extend this grammar so that numerical operations ( multiplicative, etc )
# co-erce their arguments to numerics when they are compiled.
#
# eg. "=A1*A3+2" might become "=Float(@A1.get)*Float(@A3.get)+Float(2)"
#
# We would use Float as it's more strict about the inputs and better reflects how
# Excel works when using non numeric strings. The danger in to_f is that it's too loose
# so situations where a calculation SHOULD not work are less likely to happen. Essentially
# the output doesn't match what you would see in Excel. 
#
# Currently we don't have the time to put into making this grammar correct so instead we
# have co-erced all nils to Float at runtime using Float(). This will probably fix most situations
# and still not work in situations where Excel also would not have an output. 
#
# The user is then left to handle the thrown exception or not - a situation they would need to 
# do whether the grammar was fixed/refined or not.
#
# A situation where the above fix would not work is a VLOOKUP or other function where a
# blank string is an expected input ...
#
# There is a pending spec left in the soroban spec that will detect whenever this situation has
# been rectified. When COUNTBLANK() really works we know that the cached cell value is not being
# coerced but we are compiling to coerced language/s correctly. 
# 
grammar Soroban
  rule formula
    '=' space? logical <Formula> / string / number / boolean
  end
  rule logical
    and ( space? 'or' space? and )*
  end
  rule and
    truthval ( space? 'and' space? truthval )*
  end
  rule truthval
    comparison / '(' space? logical space? ')' / boolean
  end
  rule boolean
    'true' / 'false' / 'TRUE' / 'FALSE'
  end
  rule comparison
    expression ( space? comparator space? expression )*
  end
  rule comparator
    '=' <Equal> / '<>' <NotEqual> / '>=' / '<=' / '>' / '<'
  end
  rule expression
    multiplicative ( space? additive_operator space? multiplicative )*
  end
  rule additive_operator
    '+' / '-'
  end
  rule multiplicative
    value ( space? multiplicative_operator space? value )*
  end
  rule multiplicative_operator
    '^' <Pow> / '*' / '/'
  end
  rule value
    ( function / '(' space? expression space? ')' / range / number / boolean / identifier / string / '-' value )
  end
  rule function
    [a-zA-Z]+ '(' space? arguments? space? ')' <Function>
  end
  rule arguments
    logical ( space? ',' space? logical )*
  end
  rule number
    ( float / integer / '-' float / '-' integer )
  end
  rule float
    [0-9]* '.' [0-9]+ <FloatValue>
  end
  rule integer
    [0-9]+ <IntegerValue>
  end
  rule identifier
    [a-zA-Z] [a-zA-Z0-9]* <Identifier>
  end
  rule label
    [A-Za-z]+ [1-9] [0-9]* <Label> / '$' [A-Za-z]+ '$' [1-9] [0-9]* <Label>
  end
  rule string
    '"' ('\"' / !'"' .)* '"' / "'" [^']* "'"
  end
  rule range
    label ':' label <Range>
  end
  rule space
    [\s]+
  end
end
